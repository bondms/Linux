This is more difficult than one would expect. Obey these rules!

- Terminate filenames with nul, the only character not allowed in posix paths (find -print0, sort --zero-terminated, xargs --null).
- Don't use -exec option of find if you care about catching errors; it hides the exit code of the command. Instead use xargs.
- Use single quotes around filenames to protect special characters (such as `"$) from being mishandled:
- Escape (all) single quotes in the filenames if passing to a shell (sed with global search and replace).
- If neccessary, handle the case where there are no items found (xargs --no-run-if-empty option).
- Consider whether it is necessary to limit the processing one item at a time (xargs --max-args or -I options) .
- Consider which types of files to process; files, directories, links, etc. (find -type option).
- Consider whether to include the top-level directory. For find, this is "." if no path is specified. Exclude with -mindepth 1 find option.
- Consider whether to recurse into subfolders. Disable with find -maxdepth 1 option.
- Specify the arguments to find in the appropriate order, especially -mindepth, -maxdepth etc.
- Find appears to preceed the item with a path (./ if no root search path is specified), so filenames that look like options (e.g. --file-name.txt) are not a problem, but it still might be good practice to consider these and protect against injection by using the -- argument to commands that support it.

Examples:

Multi-item processing (no -I or --max-args passed to xargs):
# find -mindepth 1 -maxdepth 1 -type f -print0 |
    sort --zero-terminated |
    xargs --null --no-run-if-empty chmod --verbose -w

Single-item processing (otherwise there won't be one "Found:" line printed for each hit:
# find -print0 |
    xargs --null --no-run-if-empty --max-args 1 echo "Found: "

Single-item processing with replacement string that doesn't go at the end of the command (use single quotes around the {}):
# find -print0 |
    xargs --null -I{} echo 'This item {} has been found.'

Processing via a shell call:
# find -type f -print0 | bash -c "
    while read -r -d $'\0' F
    do
        echo \"\$F\"
    done"

### Bad implementations ###

Perhaps use of printf bash built-in with %b or %q could help?

Processing via a shell call requiring escaping of single quotes (doesn't work with filenames containing dollar):
# find -type f -iname "*.mp3" -print0 |
    sed "s/'/'\\\''/g" |
    xargs --null --no-run-if-empty -I {} bash -c "{
        eyeD3 --no-color '{}' | cat
    } 2>&1 >/dev/null |
    if grep -F \"'ascii' codec can't encode characters in position\"
    then
        id3convert --strip '{}'
    fi"

An alternative example of making a shell call, using env rather than sed (doesn't work with filenames containing double quote):
# find /home/bondms/Music/. -type f -iname "*.mp3" -print0 |
    xargs --null -I '{}' env F='{}' bash -c "file \"\$F\" | grep -F \"layer II,\" || true"
